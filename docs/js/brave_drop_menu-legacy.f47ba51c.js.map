{"version":3,"sources":["webpack:///./src/components/BraveDropMenu.vue?7045","webpack:///./src/components/BraveDropMenu.vue?ea6e","webpack:///./src/views/CompBraveDropMenu.vue?0a50","webpack:///./src/components/BraveDropMenu.vue?927d","webpack:///./src/directives/clickoutside.js","webpack:///./node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","webpack:///./node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","webpack:///src/components/BraveDropMenu.vue","webpack:///./src/components/BraveDropMenu.vue?e0cc","webpack:///./src/components/BraveDropMenu.vue","webpack:///src/views/CompBraveDropMenu.vue","webpack:///./src/views/CompBraveDropMenu.vue?5fd0","webpack:///./src/views/CompBraveDropMenu.vue","webpack:///./src/components/BraveDropMenu.vue?2561"],"names":["___CSS_LOADER_API_IMPORT___","exports","push","module","i","render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","scopedSlots","_u","key","fn","attrs","proxy","staticStyle","_m","staticRenderFns","ref","on","$event","toggleVisiblity","_t","directives","name","rawName","value","expression","_e","priority","bind","el","binding","vnode","clickOutsideEvent","event","target","contains","context","document","body","addEventListener","unbind","removeEventListener","getBasePlacement","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","reference","floating","commonX","x","width","commonY","y","height","coords","mainAxis","length","computePosition","async","config","strategy","middleware","platform","rects","getElementRects","statefulPlacement","middlewareData","nextX","nextY","data","reset","initialPlacement","elements","expandPaddingObject","padding","top","right","bottom","left","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","boundary","rootBoundary","elementContext","altBoundary","paddingObject","altContext","element","clippingClientRect","getClippingClientRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","min","Math","max","within","min$1","max$1","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","isStart","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","_middlewareData$flip2","skip","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","detectOverflowOptions","basePlacement","isBasePlacement","placements","overflow","overflows","overflowsData","every","side","_middlewareData$flip$","_middlewareData$flip3","nextIndex","index","nextPlacement","resetPlacement","_overflowsData$slice$","slice","sort","a","b","filter","reduce","acc","convertValueToCoords","multiplier","rawValue","offset","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","isWindow","toString","getWindow","node","window","ownerDocument","defaultView","getComputedStyle$1","getComputedStyle","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","Element","isNode","Node","isShadowRoot","OwnElement","ShadowRoot","isScrollParent","overflowX","overflowY","test","isTableElement","isContainingBlock","isFirefox","navigator","userAgent","css","transform","perspective","contain","willChange","round","getBoundingClientRect","includeScale","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","documentElement","getNodeScroll","scrollLeft","pageXOffset","scrollTop","pageYOffset","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","isOffsetParentAnElement","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","getContainingBlock","currentNode","getDimensions","getViewportRect","win","html","visualViewport","clientWidth","clientHeight","abs","innerWidth","scale","offsetLeft","offsetTop","getDocumentRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getScrollParent","getScrollParents","list","_node$ownerDocument","scrollParent","isBody","concat","updatedList","parent","child","rootNode","getRootNode","next","getInnerBoundingClientRect","getClientRectFromClippingParent","clippingParent","getClippingParents","clippingParents","canEscapeClipping","clipperElement","mainClippingParents","firstClippingParent","clippingRect","accRect","args","_ref2","_ref3","_ref4","getClientRects","_ref5","computed","created","updated","methods","component","components","BraveDropMenu","BraveGistEmbed","content","__esModule","default","locals","add"],"mappings":"sGACA,IAAIA,EAA8B,EAAQ,QAC1CC,EAAUD,GAA4B,GAEtCC,EAAQC,KAAK,CAACC,EAAOC,EAAI,shBAAuhB,KAEhjBD,EAAOF,QAAUA,G,oCCNjB,W,2CCAA,IAAII,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,yBAAyB,CAACF,EAAG,KAAK,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,qBAAqBH,EAAG,IAAI,CAACJ,EAAIO,GAAG,8EAA8EH,EAAG,KAAK,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,aAAaH,EAAG,IAAI,CAACJ,EAAIO,GAAG,4DAA4DH,EAAG,gBAAgB,CAACE,YAAY,OAAOE,YAAYR,EAAIS,GAAG,CAAC,CAACC,IAAI,SAASC,GAAG,WAAW,MAAO,CAACP,EAAG,MAAM,CAACE,YAAY,mCAAmCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,kBAAkBN,EAAIO,GAAG,YAAYH,EAAG,IAAI,CAACE,YAAY,2BAA2BO,OAAM,GAAM,CAACH,IAAI,OAAOC,GAAG,WAAW,MAAO,CAACP,EAAG,MAAM,CAACE,YAAY,6BAA6BQ,YAAY,CAAC,YAAY,UAAU,CAACV,EAAG,MAAM,CAACE,YAAY,yCAAyCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,2BAA2BN,EAAIO,GAAG,yBAAyBH,EAAG,MAAM,CAACE,YAAY,yCAAyCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,6BAA6BN,EAAIO,GAAG,6BAA6BM,OAAM,OAAUT,EAAG,gBAAgB,CAACI,YAAYR,EAAIS,GAAG,CAAC,CAACC,IAAI,SAASC,GAAG,WAAW,MAAO,CAACP,EAAG,MAAM,CAACE,YAAY,uBAAuBM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,kBAAkBN,EAAIO,GAAG,YAAYH,EAAG,IAAI,CAACE,YAAY,2BAA2BO,OAAM,GAAM,CAACH,IAAI,OAAOC,GAAG,WAAW,MAAO,CAACP,EAAG,MAAM,CAACE,YAAY,6BAA6BQ,YAAY,CAAC,YAAY,UAAU,CAACV,EAAG,MAAM,CAACE,YAAY,yCAAyCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,2BAA2BN,EAAIO,GAAG,yBAAyBH,EAAG,MAAM,CAACE,YAAY,yCAAyCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,6BAA6BN,EAAIO,GAAG,6BAA6BM,OAAM,OAAUT,EAAG,IAAI,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,qCAAqCH,EAAG,gBAAgB,CAACI,YAAYR,EAAIS,GAAG,CAAC,CAACC,IAAI,SAASC,GAAG,WAAW,MAAO,CAACP,EAAG,OAAO,CAACE,YAAY,eAAeM,MAAM,CAAC,KAAO,WAAW,CAACZ,EAAIO,GAAG,0BAA0BM,OAAM,GAAM,CAACH,IAAI,OAAOC,GAAG,WAAW,MAAO,CAACP,EAAG,MAAM,CAACE,YAAY,6BAA6BQ,YAAY,CAAC,YAAY,UAAU,CAACV,EAAG,MAAM,CAACE,YAAY,yCAAyCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,2BAA2BN,EAAIO,GAAG,yBAAyBH,EAAG,MAAM,CAACE,YAAY,yCAAyCM,MAAM,CAAC,KAAO,WAAW,CAACR,EAAG,IAAI,CAACE,YAAY,6BAA6BN,EAAIO,GAAG,6BAA6BM,OAAM,QAAW,GAAGT,EAAG,MAAMA,EAAG,KAAK,CAACJ,EAAIO,GAAG,2BAA2BH,EAAG,iBAAiB,CAACQ,MAAM,CAAC,IAAM,2EAA2ER,EAAG,KAAK,CAACE,YAAY,SAASF,EAAG,KAAK,CAACJ,EAAIO,GAAG,gBAAgBH,EAAG,KAAK,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,qDAAqDP,EAAIe,GAAG,GAAGX,EAAG,KAAK,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,+BAA+BP,EAAIe,GAAG,GAAGX,EAAG,KAAK,CAACE,YAAY,QAAQ,CAACN,EAAIO,GAAG,6BAA6BP,EAAIe,GAAG,GAAGf,EAAIe,GAAG,GAAGX,EAAG,KAAK,CAACA,EAAG,KAAK,CAACJ,EAAIO,GAAG,8BAA8BH,EAAG,iBAAiB,CAACQ,MAAM,CAAC,IAAM,4EAA4E,GAAGR,EAAG,KAAK,CAACJ,EAAIO,GAAG,8BAA8BH,EAAG,iBAAiB,CAACQ,MAAM,CAAC,IAAM,4EAA4E,GAAGR,EAAG,KAAK,CAACJ,EAAIO,GAAG,mBAAmBH,EAAG,iBAAiB,CAACQ,MAAM,CAAC,IAAM,4EAA4E,KAAKR,EAAG,MAAMA,EAAG,KAAK,CAACJ,EAAIO,GAAG,aAAaH,EAAG,IAAI,CAACJ,EAAIO,GAAG,yIAAyI,IAClvHS,EAAkB,CAAC,WAAa,IAAIhB,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,QAAQ,CAACF,EAAG,OAAO,CAACE,YAAY,sBAAsB,CAACN,EAAIO,GAAG,+CAAiD,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,QAAQ,CAACF,EAAG,OAAO,CAACE,YAAY,sBAAsB,CAACN,EAAIO,GAAG,8CAA8C,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACJ,EAAIO,GAAG,eAAeH,EAAG,OAAO,CAACE,YAAY,WAAW,CAACN,EAAIO,GAAG,eAAeP,EAAIO,GAAG,0BAA0B,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,KAAK,CAACA,EAAG,KAAK,CAACA,EAAG,MAAM,CAACE,YAAY,WAAW,CAACN,EAAIO,GAAG,YAAYP,EAAIO,GAAG,kGAAkGH,EAAG,KAAK,CAACA,EAAG,MAAM,CAACE,YAAY,WAAW,CAACN,EAAIO,GAAG,UAAUP,EAAIO,GAAG,oCCDj9B,EAAS,WAAa,IAAIP,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,eAAe,CAACF,EAAG,MAAM,CAACa,IAAI,SAASX,YAAY,YAAYY,GAAG,CAAC,MAAQ,SAASC,GAAQ,OAAOnB,EAAIoB,qBAAqB,CAACpB,EAAIqB,GAAG,UAAS,WAAW,MAAO,CAACrB,EAAIO,GAAG,aAAY,GAAIP,EAAa,UAAEI,EAAG,MAAM,CAACkB,WAAW,CAAC,CAACC,KAAK,eAAeC,QAAQ,iBAAiBC,MAAOzB,EAAiB,cAAE0B,WAAW,kBAAkBT,IAAI,OAAOX,YAAY,kBAAkB,CAACN,EAAIqB,GAAG,SAAS,GAAGrB,EAAI2B,QACpf,EAAkB,GCDP,G,UAAA,CACbC,SAAU,IACVC,KAAM,SAAUC,EAAIC,EAASC,GAC3BF,EAAGG,kBAAoB,SAAUC,GAEzBJ,GAAMI,EAAMC,QAAUL,EAAGM,SAASF,EAAMC,SAE5CH,EAAMK,QAAQN,EAAQL,YAAYQ,IAGtCI,SAASC,KAAKC,iBAAiB,QAASV,EAAGG,oBAE7CQ,OAAQ,SAAUX,GAChBQ,SAASC,KAAKG,oBAAoB,QAASZ,EAAGG,sBCblD,SAASU,EAAiBC,GACxB,OAAOA,EAAUC,MAAM,KAAK,GAG9B,SAASC,EAAaF,GACpB,OAAOA,EAAUC,MAAM,KAAK,GAG9B,SAASE,EAAyBH,GAChC,MAAO,CAAC,MAAO,UAAUI,SAASL,EAAiBC,IAAc,IAAM,IAGzE,SAASK,EAAkBC,GACzB,MAAgB,MAATA,EAAe,SAAW,QAGnC,SAASC,EAA2BC,GAClC,IAAI,UACFC,EAAS,SACTC,EAAQ,UACRV,GACEQ,EACJ,MAAMG,EAAUF,EAAUG,EAAIH,EAAUI,MAAQ,EAAIH,EAASG,MAAQ,EAC/DC,EAAUL,EAAUM,EAAIN,EAAUO,OAAS,EAAIN,EAASM,OAAS,EACvE,IAAIC,EAEJ,OAAQlB,EAAiBC,IACvB,IAAK,MACHiB,EAAS,CACPL,EAAGD,EACHI,EAAGN,EAAUM,EAAIL,EAASM,QAE5B,MAEF,IAAK,SACHC,EAAS,CACPL,EAAGD,EACHI,EAAGN,EAAUM,EAAIN,EAAUO,QAE7B,MAEF,IAAK,QACHC,EAAS,CACPL,EAAGH,EAAUG,EAAIH,EAAUI,MAC3BE,EAAGD,GAEL,MAEF,IAAK,OACHG,EAAS,CACPL,EAAGH,EAAUG,EAAIF,EAASG,MAC1BE,EAAGD,GAEL,MAEF,QACEG,EAAS,CACPL,EAAGH,EAAUG,EACbG,EAAGN,EAAUM,GAInB,MAAMG,EAAWf,EAAyBH,GACpCmB,EAASd,EAAkBa,GAEjC,OAAQhB,EAAaF,IACnB,IAAK,QACHiB,EAAOC,GAAYD,EAAOC,IAAaT,EAAUU,GAAU,EAAIT,EAASS,GAAU,GAClF,MAEF,IAAK,MACHF,EAAOC,GAAYD,EAAOC,IAAaT,EAAUU,GAAU,EAAIT,EAASS,GAAU,GAClF,MAGJ,OAAOF,EAGT,MAAMG,EAAkBC,MAAOZ,EAAWC,EAAUY,KAClD,MAAM,UACJtB,EAAY,SAAQ,SACpBuB,EAAW,WAAU,WACrBC,EAAa,GAAE,SACfC,GACEH,EAiBJ,IAAII,QAAcD,EAASE,gBAAgB,CACzClB,YACAC,WACAa,cAEE,EACFX,EAAC,EACDG,GACER,EAA2B,IAAKmB,EAClC1B,cAEE4B,EAAoB5B,EACpB6B,EAAiB,GAGrB,IAAK,IAAI3E,EAAI,EAAGA,EAAIsE,EAAWL,OAAQjE,IAAK,CACtC,EAQJ,MAAM,KACJyB,EAAI,GACJZ,GACEyD,EAAWtE,IAEb0D,EAAGkB,EACHf,EAAGgB,EAAK,KACRC,EAAI,MACJC,SACQlE,EAAG,CACX6C,IACAG,IACAmB,iBAAkBlC,EAClBA,UAAW4B,EACXL,WACAM,iBACAH,QACAD,WACAU,SAAU,CACR1B,YACAC,cAGJE,EAAa,MAATkB,EAAgBA,EAAQlB,EAC5BG,EAAa,MAATgB,EAAgBA,EAAQhB,EAC5Bc,EAAiB,IAAKA,EACpB,CAAClD,GAAe,MAARqD,EAAeA,EAAO,IAG5BC,IACmB,kBAAVA,IACLA,EAAMjC,YACR4B,EAAoBK,EAAMjC,WAGxBiC,EAAMP,QACRA,GAAwB,IAAhBO,EAAMP,YAAuBD,EAASE,gBAAgB,CAC5DlB,YACAC,WACAa,aACGU,EAAMP,SAIXd,IACAG,KACER,EAA2B,IAAKmB,EAClC1B,UAAW4B,MAIf1E,GAAK,GAKT,MAAO,CACL0D,IACAG,IACAf,UAAW4B,EACXL,WACAM,mBAIJ,SAASO,EAAoBC,GAC3B,MAAO,CACLC,IAAK,EACLC,MAAO,EACPC,OAAQ,EACRC,KAAM,KACHJ,GAIP,SAASK,EAAyBL,GAChC,MAA0B,kBAAZA,EAAuBD,EAAoBC,GAAW,CAClEC,IAAKD,EACLE,MAAOF,EACPG,OAAQH,EACRI,KAAMJ,GAIV,SAASM,EAAiBC,GACxB,MAAO,IAAKA,EACVN,IAAKM,EAAK7B,EACV0B,KAAMG,EAAKhC,EACX2B,MAAOK,EAAKhC,EAAIgC,EAAK/B,MACrB2B,OAAQI,EAAK7B,EAAI6B,EAAK5B,QAI1BK,eAAewB,EAAeC,EAAqBC,QACjC,IAAZA,IACFA,EAAU,IAGZ,MAAM,EACJnC,EAAC,EACDG,EAAC,SACDU,EAAQ,MACRC,EAAK,SACLS,EAAQ,SACRZ,GACEuB,GACE,SACJE,EAAW,kBAAiB,aAC5BC,EAAe,WAAU,eACzBC,EAAiB,WAAU,YAC3BC,GAAc,EAAK,QACnBd,EAAU,GACRU,EACEK,EAAgBV,EAAyBL,GACzCgB,EAAgC,aAAnBH,EAAgC,YAAc,WAC3DI,EAAUnB,EAASgB,EAAcE,EAAaH,GAC9CK,QAA2B9B,EAAS+B,sBAAsB,CAC9DF,cAAgB7B,EAASgC,UAAUH,GAAYA,EAAUA,EAAQI,sBAAyBjC,EAASkC,mBAAmB,CACpHL,QAASnB,EAASzB,WAEpBsC,WACAC,iBAEIW,EAAoBjB,QAAuBlB,EAASoC,sDAAsD,CAC9GjB,KAAyB,aAAnBM,EAAgC,IAAKxB,EAAMhB,SAC/CE,IACAG,KACEW,EAAMjB,UACVqD,mBAAoBrC,EAASsC,gBAAgB,CAC3CT,QAASnB,EAASzB,WAEpBa,cAIF,MAAO,CACLe,IAAKiB,EAAmBjB,IAAMsB,EAAkBtB,IAAMc,EAAcd,IACpEE,OAAQoB,EAAkBpB,OAASe,EAAmBf,OAASY,EAAcZ,OAC7EC,KAAMc,EAAmBd,KAAOmB,EAAkBnB,KAAOW,EAAcX,KACvEF,MAAOqB,EAAkBrB,MAAQgB,EAAmBhB,MAAQa,EAAcb,OAI9E,MAAMyB,EAAMC,KAAKD,IACXE,EAAMD,KAAKC,IAEjB,SAASC,EAAOC,EAAOvF,EAAOwF,GAC5B,OAAOH,EAAIE,EAAOJ,EAAInF,EAAOwF,IAG/B,MA8DMC,EAAS,CACb7B,KAAM,QACNF,MAAO,OACPC,OAAQ,MACRF,IAAK,UAEP,SAASiC,EAAqBvE,GAC5B,OAAOA,EAAUwE,QAAQ,yBAA0BC,GAAWH,EAAOG,IAGvE,SAASC,EAAkB1E,EAAW0B,GACpC,MAAMiD,EAAsC,UAA5BzE,EAAaF,GACvBkB,EAAWf,EAAyBH,GACpCmB,EAASd,EAAkBa,GACjC,IAAI0D,EAAiC,MAAb1D,EAAmByD,EAAU,QAAU,OAASA,EAAU,SAAW,MAM7F,OAJIjD,EAAMjB,UAAUU,GAAUO,EAAMhB,SAASS,KAC3CyD,EAAoBL,EAAqBK,IAGpC,CACLC,KAAMD,EACNE,MAAOP,EAAqBK,IAIhC,MAAMG,EAAO,CACXC,MAAO,MACPC,IAAK,SAEP,SAASC,EAA8BlF,GACrC,OAAOA,EAAUwE,QAAQ,aAAcC,GAAWM,EAAKN,IAwGzD,SAASU,EAAsBnF,GAC7B,MAAMoF,EAAoBb,EAAqBvE,GAC/C,MAAO,CAACkF,EAA8BlF,GAAYoF,EAAmBF,EAA8BE,IAGrG,MAAMC,EAAO,SAAUtC,GAKrB,YAJgB,IAAZA,IACFA,EAAU,IAGL,CACLpE,KAAM,OACNoE,UAEA,SAASD,GACP,IAAIwC,EAAsBC,EAE1B,MAAM,UACJvF,EAAS,eACT6B,EAAc,MACdH,EAAK,iBACLQ,GACEY,EAEJ,GAAoD,OAA/CwC,EAAuBzD,EAAewD,OAAiBC,EAAqBE,KAC/E,MAAO,GAGT,MACEtE,SAAUuE,GAAgB,EAC1BC,UAAWC,GAAiB,EAC5BC,mBAAoBC,EAA2B,iBAC/CC,EAAmB,UAAS,cAC5BC,GAAgB,KACbC,GACDjD,EACEkD,EAAgBlG,EAAiBC,GACjCkG,EAAkBD,IAAkB/D,EACpC0D,EAAqBC,IAAgCK,IAAoBH,EAAgB,CAACxB,EAAqBrC,IAAqBiD,EAAsBjD,IAC1JiE,EAAa,CAACjE,KAAqB0D,GACnCQ,QAAiBvD,EAAeC,EAAqBkD,GACrDK,EAAY,GAClB,IAAIC,GAAkE,OAAhDf,EAAwB1D,EAAewD,WAAgB,EAASE,EAAsBc,YAAc,GAM1H,GAJIZ,GACFY,EAAUrJ,KAAKoJ,EAASH,IAGtBN,EAAgB,CAClB,MAAM,KACJd,EAAI,MACJC,GACEJ,EAAkB1E,EAAW0B,GACjC2E,EAAUrJ,KAAKoJ,EAASvB,GAAOuB,EAAStB,IAQ1C,GALAwB,EAAgB,IAAIA,EAAe,CACjCtG,YACAqG,eAGGA,EAAUE,MAAMC,GAAQA,GAAQ,GAAI,CACvC,IAAIC,EAAuBC,EAE3B,MAAMC,GAAuI,OAAzHF,EAAyE,OAAhDC,EAAwB7E,EAAewD,WAAgB,EAASqB,EAAsBE,OAAiBH,EAAwB,GAAK,EAC3KI,EAAgBV,EAAWQ,GAEjC,GAAIE,EAEF,MAAO,CACL7E,KAAM,CACJ4E,MAAOD,EACPN,UAAWC,GAEbrE,MAAO,CACLjC,UAAW6G,IAKjB,IAAIC,EAAiB,SAErB,OAAQhB,GACN,IAAK,UACH,CACE,IAAIiB,EAEJ,MAAM/G,EAAwQ,OAA3P+G,EAAwBT,EAAcU,QAAQC,KAAK,CAACC,EAAGC,IAAMD,EAAEb,UAAUe,OAAOhB,GAAYA,EAAW,GAAGiB,OAAO,CAACC,EAAKlB,IAAakB,EAAMlB,EAAU,GAAKe,EAAEd,UAAUe,OAAOhB,GAAYA,EAAW,GAAGiB,OAAO,CAACC,EAAKlB,IAAakB,EAAMlB,EAAU,IAAI,SAAc,EAASW,EAAsB/G,UAEhTA,IACF8G,EAAiB9G,GAGnB,MAGJ,IAAK,mBACH8G,EAAiB5E,EACjB,MAGJ,MAAO,CACLF,KAAM,CACJwD,MAAM,GAERvD,MAAO,CACLjC,UAAW8G,IAKjB,MAAO,MA6Cb,SAASS,EAAqB/G,GAC5B,IAAI,UACFR,EAAS,MACT0B,EAAK,MACL7C,GACE2B,EACJ,MAAMyF,EAAgBlG,EAAiBC,GACjCwH,EAAa,CAAC,OAAQ,OAAOpH,SAAS6F,IAAkB,EAAI,EAC5DwB,EAA4B,oBAAV5I,EAAuBA,EAAM,IAAK6C,EACxD1B,cACGnB,GACC,SACJqC,EAAQ,UACRwE,GACsB,kBAAb+B,EAAwB,CACjCvG,SAAUuG,EACV/B,UAAW,GACT,CACFxE,SAAU,EACVwE,UAAW,KACR+B,GAEL,MAAmD,MAA5CtH,EAAyB8F,GAAyB,CACvDrF,EAAG8E,EACH3E,EAAGG,EAAWsG,GACZ,CACF5G,EAAGM,EAAWsG,EACdzG,EAAG2E,GAGP,MAAMgC,EAAS,SAAU7I,GAKvB,YAJc,IAAVA,IACFA,EAAQ,GAGH,CACLF,KAAM,SACNoE,QAASlE,EAET,GAAGiE,GACD,MAAM,EACJlC,EAAC,EACDG,EAAC,UACDf,EAAS,MACT0B,GACEoB,EACE6E,EAAaJ,EAAqB,CACtCvH,YACA0B,QACA7C,UAEF,MAAO,CACL+B,EAAGA,EAAI+G,EAAW/G,EAClBG,EAAGA,EAAI4G,EAAW5G,EAClBiB,KAAM2F,MAOd,SAASC,EAAatH,GACpB,MAAgB,MAATA,EAAe,IAAM,IAG9B,MAAMuH,EAAQ,SAAU9E,GAKtB,YAJgB,IAAZA,IACFA,EAAU,IAGL,CACLpE,KAAM,QACNoE,UAEA,SAASD,GACP,MAAM,EACJlC,EAAC,EACDG,EAAC,UACDf,GACE8C,GAEF5B,SAAUuE,GAAgB,EAC1BC,UAAWC,GAAiB,EAAK,QACjCmC,EAAU,CACR/J,GAAIyC,IACF,IAAI,EACFI,EAAC,EACDG,GACEP,EACJ,MAAO,CACLI,IACAG,UAIHiF,GACDjD,EACE9B,EAAS,CACbL,IACAG,KAEIqF,QAAiBvD,EAAeC,EAAqBkD,GACrD9E,EAAWf,EAAyBJ,EAAiBC,IACrD0F,EAAYkC,EAAa1G,GAC/B,IAAI6G,EAAgB9G,EAAOC,GACvB8G,EAAiB/G,EAAOyE,GAE5B,GAAID,EAAe,CACjB,MAAMwC,EAAuB,MAAb/G,EAAmB,MAAQ,OACrCgH,EAAuB,MAAbhH,EAAmB,SAAW,QACxC8C,EAAM+D,EAAgB3B,EAAS6B,GAC/B/D,EAAM6D,EAAgB3B,EAAS8B,GACrCH,EAAgB5D,EAAOH,EAAK+D,EAAe7D,GAG7C,GAAIyB,EAAgB,CAClB,MAAMsC,EAAwB,MAAdvC,EAAoB,MAAQ,OACtCwC,EAAwB,MAAdxC,EAAoB,SAAW,QACzC1B,EAAMgE,EAAiB5B,EAAS6B,GAChC/D,EAAM8D,EAAiB5B,EAAS8B,GACtCF,EAAiB7D,EAAOH,EAAKgE,EAAgB9D,GAG/C,MAAMiE,EAAgBL,EAAQ/J,GAAG,IAAK+E,EACpC,CAAC5B,GAAW6G,EACZ,CAACrC,GAAYsC,IAEf,MAAO,IAAKG,EACVnG,KAAM,CACJpB,EAAGuH,EAAcvH,EAAIA,EACrBG,EAAGoH,EAAcpH,EAAIA,OCnvB/B,SAASqH,EAASvJ,GAChB,MAAuD,qBAAtC,MAATA,OAAgB,EAASA,EAAMwJ,YAEzC,SAASC,EAAUC,GACjB,GAAY,MAARA,EACF,OAAOC,OAGT,IAAKJ,EAASG,GAAO,CACnB,MAAME,EAAgBF,EAAKE,cAC3B,OAAOA,GAAgBA,EAAcC,aAAwBF,OAG/D,OAAOD,EAGT,SAASI,EAAmBrF,GAC1B,OAAOgF,EAAUhF,GAASsF,iBAAiBtF,GAG7C,SAASuF,EAAYN,GACnB,OAAOH,EAASG,GAAQ,GAAKA,GAAQA,EAAKO,UAAY,IAAIC,cAAgB,GAG5E,SAASC,EAAcnK,GACrB,OAAOA,aAAiByJ,EAAUzJ,GAAOoK,YAE3C,SAASxF,EAAU5E,GACjB,OAAOA,aAAiByJ,EAAUzJ,GAAOqK,QAE3C,SAASC,EAAOtK,GACd,OAAOA,aAAiByJ,EAAUzJ,GAAOuK,KAE3C,SAASC,EAAad,GACpB,MAAMe,EAAahB,EAAUC,GAAMgB,WACnC,OAAOhB,aAAgBe,GAAcf,aAAgBgB,WAEvD,SAASC,EAAelG,GAEtB,MAAM,SACJ8C,EAAQ,UACRqD,EAAS,UACTC,GACEf,EAAmBrF,GACvB,MAAO,6BAA6BqG,KAAKvD,EAAWsD,EAAYD,GAElE,SAASG,EAAetG,GACtB,MAAO,CAAC,QAAS,KAAM,MAAMlD,SAASyI,EAAYvF,IAEpD,SAASuG,EAAkBvG,GAEzB,MAAMwG,EAAYC,UAAUC,UAAUjB,cAAc3I,SAAS,WACvD6J,EAAMtB,EAAmBrF,GAI/B,MAAyB,SAAlB2G,EAAIC,WAA4C,SAApBD,EAAIE,aAA0C,UAAhBF,EAAIG,SAAuB,CAAC,YAAa,eAAehK,SAAS6J,EAAII,aAAeP,GAAgC,WAAnBG,EAAII,YAA2BP,KAAcG,EAAI7C,QAAwB,SAAf6C,EAAI7C,OAGlO,MAAM,EAAMnD,KAAKD,IACX,EAAMC,KAAKC,IACXoG,EAAQrG,KAAKqG,MAEnB,SAASC,EAAsBjH,EAASkH,QACjB,IAAjBA,IACFA,GAAe,GAGjB,MAAMC,EAAanH,EAAQiH,wBAC3B,IAAIG,EAAS,EACTC,EAAS,EAOb,OALIH,GAAgBxB,EAAc1F,KAChCoH,EAASpH,EAAQsH,YAAc,GAAIN,EAAMG,EAAW5J,OAASyC,EAAQsH,aAAmB,EACxFD,EAASrH,EAAQuH,aAAe,GAAIP,EAAMG,EAAWzJ,QAAUsC,EAAQuH,cAAoB,GAGtF,CACLhK,MAAO4J,EAAW5J,MAAQ6J,EAC1B1J,OAAQyJ,EAAWzJ,OAAS2J,EAC5BrI,IAAKmI,EAAWnI,IAAMqI,EACtBpI,MAAOkI,EAAWlI,MAAQmI,EAC1BlI,OAAQiI,EAAWjI,OAASmI,EAC5BlI,KAAMgI,EAAWhI,KAAOiI,EACxB9J,EAAG6J,EAAWhI,KAAOiI,EACrB3J,EAAG0J,EAAWnI,IAAMqI,GAIxB,SAAShH,EAAmB4E,GAC1B,QAASY,EAAOZ,GAAQA,EAAKE,cAAgBF,EAAK7I,WAAa8I,OAAO9I,UAAUoL,gBAGlF,SAASC,EAAczH,GACrB,OAAI8E,EAAS9E,GACJ,CACL0H,WAAY1H,EAAQ2H,YACpBC,UAAW5H,EAAQ6H,aAIhB,CACLH,WAAY1H,EAAQ0H,WACpBE,UAAW5H,EAAQ4H,WAIvB,SAASE,EAAoB9H,GAG3B,OAAOiH,EAAsB5G,EAAmBL,IAAUb,KAAOsI,EAAczH,GAAS0H,WAG1F,SAASK,EAAS/H,GAChB,MAAMV,EAAO2H,EAAsBjH,GACnC,OAAOgH,EAAM1H,EAAK/B,SAAWyC,EAAQsH,aAAeN,EAAM1H,EAAK5B,UAAYsC,EAAQuH,aAGrF,SAASS,EAA8BhI,EAASQ,EAAcvC,GAC5D,MAAMgK,EAA0BvC,EAAclF,GACxCgH,EAAkBnH,EAAmBG,GACrClB,EAAO2H,EAAsBjH,EAASiI,GAA2BF,EAASvH,IAChF,IAAI0H,EAAS,CACXR,WAAY,EACZE,UAAW,GAEb,MAAMO,EAAU,CACd7K,EAAG,EACHG,EAAG,GAGL,GAAIwK,IAA4BA,GAAwC,UAAbhK,EAKzD,IAJkC,SAA9BsH,EAAY/E,IAA4B0F,EAAesB,MACzDU,EAAST,EAAcjH,IAGrBkF,EAAclF,GAAe,CAC/B,MAAM4H,EAAanB,EAAsBzG,GAAc,GACvD2H,EAAQ7K,EAAI8K,EAAW9K,EAAIkD,EAAa6H,WACxCF,EAAQ1K,EAAI2K,EAAW3K,EAAI+C,EAAa8H,eAC/Bd,IACTW,EAAQ7K,EAAIwK,EAAoBN,IAIpC,MAAO,CACLlK,EAAGgC,EAAKH,KAAO+I,EAAOR,WAAaS,EAAQ7K,EAC3CG,EAAG6B,EAAKN,IAAMkJ,EAAON,UAAYO,EAAQ1K,EACzCF,MAAO+B,EAAK/B,MACZG,OAAQ4B,EAAK5B,QAIjB,SAAS6K,EAActD,GACrB,MAA0B,SAAtBM,EAAYN,GACPA,EAKPA,EAAKuD,cACLvD,EAAKwD,aACL1C,EAAad,GAAQA,EAAKyD,KAAO,OACjCrI,EAAmB4E,GAKvB,SAAS0D,EAAoB3I,GAC3B,OAAK0F,EAAc1F,IAAmD,UAAvCsF,iBAAiBtF,GAAS4I,SAIlD5I,EAAQQ,aAHN,KAMX,SAASqI,GAAmB7I,GAC1B,IAAI8I,EAAcP,EAAcvI,GAEhC,MAAO0F,EAAcoD,KAAiB,CAAC,OAAQ,QAAQhM,SAASyI,EAAYuD,IAAe,CACzF,GAAIvC,EAAkBuC,GACpB,OAAOA,EAEPA,EAAcA,EAAYL,WAI9B,OAAO,KAKT,SAAShI,GAAgBT,GACvB,MAAMkF,EAASF,EAAUhF,GACzB,IAAIQ,EAAemI,EAAoB3I,GAEvC,MAAOQ,GAAgB8F,EAAe9F,IAA6D,WAA5C8E,iBAAiB9E,GAAcoI,SACpFpI,EAAemI,EAAoBnI,GAGrC,OAAIA,IAA+C,SAA9B+E,EAAY/E,IAA0D,SAA9B+E,EAAY/E,IAAwE,WAA5C8E,iBAAiB9E,GAAcoI,WAA0BrC,EAAkB/F,IACvK0E,EAGF1E,GAAgBqI,GAAmB7I,IAAYkF,EAGxD,SAAS6D,GAAc/I,GACrB,MAAO,CACLzC,MAAOyC,EAAQsH,YACf5J,OAAQsC,EAAQuH,cAIpB,SAAShH,GAAsDrD,GAC7D,IAAI,KACFoC,EAAI,aACJkB,EAAY,SACZvC,GACEf,EACJ,MAAM+K,EAA0BvC,EAAclF,GACxCgH,EAAkBnH,EAAmBG,GAE3C,GAAIA,IAAiBgH,EACnB,OAAOlI,EAGT,IAAI4I,EAAS,CACXR,WAAY,EACZE,UAAW,GAEb,MAAMO,EAAU,CACd7K,EAAG,EACHG,EAAG,GAGL,IAAIwK,IAA4BA,GAAwC,UAAbhK,MACvB,SAA9BsH,EAAY/E,IAA4B0F,EAAesB,MACzDU,EAAST,EAAcjH,IAGrBkF,EAAclF,IAAe,CAC/B,MAAM4H,EAAanB,EAAsBzG,GAAc,GACvD2H,EAAQ7K,EAAI8K,EAAW9K,EAAIkD,EAAa6H,WACxCF,EAAQ1K,EAAI2K,EAAW3K,EAAI+C,EAAa8H,UAQ5C,MAAO,IAAKhJ,EACVhC,EAAGgC,EAAKhC,EAAI4K,EAAOR,WAAaS,EAAQ7K,EACxCG,EAAG6B,EAAK7B,EAAIyK,EAAON,UAAYO,EAAQ1K,GAI3C,SAASuL,GAAgBhJ,GACvB,MAAMiJ,EAAMjE,EAAUhF,GAChBkJ,EAAO7I,EAAmBL,GAC1BmJ,EAAiBF,EAAIE,eAC3B,IAAI5L,EAAQ2L,EAAKE,YACb1L,EAASwL,EAAKG,aACd/L,EAAI,EACJG,EAAI,EAeR,OAbI0L,IACF5L,EAAQ4L,EAAe5L,MACvBG,EAASyL,EAAezL,OAKpBiD,KAAK2I,IAAIL,EAAIM,WAAaJ,EAAeK,MAAQL,EAAe5L,OAAS,MAC3ED,EAAI6L,EAAeM,WACnBhM,EAAI0L,EAAeO,YAIhB,CACLnM,QACAG,SACAJ,IACAG,KAMJ,SAASkM,GAAgB3J,GACvB,IAAI4J,EAEJ,MAAMV,EAAO7I,EAAmBL,GAC1BkI,EAAST,EAAczH,GACvB3D,EAA0D,OAAlDuN,EAAwB5J,EAAQmF,oBAAyB,EAASyE,EAAsBvN,KAChGkB,EAAQ,EAAI2L,EAAKW,YAAaX,EAAKE,YAAa/M,EAAOA,EAAKwN,YAAc,EAAGxN,EAAOA,EAAK+M,YAAc,GACvG1L,EAAS,EAAIwL,EAAKY,aAAcZ,EAAKG,aAAchN,EAAOA,EAAKyN,aAAe,EAAGzN,EAAOA,EAAKgN,aAAe,GAClH,IAAI/L,GAAK4K,EAAOR,WAAaI,EAAoB9H,GACjD,MAAMvC,GAAKyK,EAAON,UAMlB,MAJmD,QAA/CvC,EAAmBhJ,GAAQ6M,GAAMa,YACnCzM,GAAK,EAAI4L,EAAKE,YAAa/M,EAAOA,EAAK+M,YAAc,GAAK7L,GAGrD,CACLA,QACAG,SACAJ,IACAG,KAIJ,SAASuM,GAAgB/E,GACvB,MAAI,CAAC,OAAQ,OAAQ,aAAanI,SAASyI,EAAYN,IAE9CA,EAAKE,cAAc9I,KAGxBqJ,EAAcT,IAASiB,EAAejB,GACjCA,EAGF+E,GAAgBzB,EAActD,IAGvC,SAASgF,GAAiBhF,EAAMiF,GAC9B,IAAIC,OAES,IAATD,IACFA,EAAO,IAGT,MAAME,EAAeJ,GAAgB/E,GAC/BoF,EAASD,KAAgE,OAA7CD,EAAsBlF,EAAKE,oBAAyB,EAASgF,EAAoB9N,MAC7G4M,EAAMjE,EAAUoF,GAChBnO,EAASoO,EAAS,CAACpB,GAAKqB,OAAOrB,EAAIE,gBAAkB,GAAIjD,EAAekE,GAAgBA,EAAe,IAAMA,EAC7GG,EAAcL,EAAKI,OAAOrO,GAChC,OAAOoO,EAASE,EAChBA,EAAYD,OAAOL,GAAiB1B,EAActM,KAGpD,SAASC,GAASsO,EAAQC,GACxB,MAAMC,EAAgC,MAArBD,EAAME,iBAAsB,EAASF,EAAME,cAE5D,GAAIH,EAAOtO,SAASuO,GAClB,OAAO,EAEJ,GAAIC,GAAY3E,EAAa2E,GAAW,CAC3C,IAAIE,EAAOH,EAEX,EAAG,CAED,GAAIG,GAAQJ,IAAWI,EACrB,OAAO,EAITA,EAAOA,EAAKnC,YAAcmC,EAAKlC,WACxBkC,GAGX,OAAO,EAGT,SAASC,GAA2B7K,GAClC,MAAMmH,EAAaF,EAAsBjH,GACnChB,EAAMmI,EAAWnI,IAAMgB,EAAQsI,UAC/BnJ,EAAOgI,EAAWhI,KAAOa,EAAQqI,WACvC,MAAO,CACLrJ,MACAG,OACA7B,EAAG6B,EACH1B,EAAGuB,EACHC,MAAOE,EAAOa,EAAQoJ,YACtBlK,OAAQF,EAAMgB,EAAQqJ,aACtB9L,MAAOyC,EAAQoJ,YACf1L,OAAQsC,EAAQqJ,cAIpB,SAASyB,GAAgC9K,EAAS+K,GAChD,MAAuB,aAAnBA,EACK1L,EAAiB2J,GAAgBhJ,IAGtCG,EAAU4K,GACLF,GAA2BE,GAG7B1L,EAAiBsK,GAAgBtJ,EAAmBL,KAM7D,SAASgL,GAAmBhL,GAC1B,MAAMiL,EAAkBhB,GAAiB1B,EAAcvI,IACjDkL,EAAoB,CAAC,WAAY,SAASpO,SAASuI,EAAmBrF,GAAS4I,UAC/EuC,EAAiBD,GAAqBxF,EAAc1F,GAAWS,GAAgBT,GAAWA,EAEhG,OAAKG,EAAUgL,GAKRF,EAAgBnH,OAAOiH,GAAkB5K,EAAU4K,IAAmB7O,GAAS6O,EAAgBI,IAAmD,SAAhC5F,EAAYwF,IAJ5H,GASX,SAAS7K,GAAsBhD,GAC7B,IAAI,QACF8C,EAAO,SACPN,EAAQ,aACRC,GACEzC,EACJ,MAAMkO,EAAmC,oBAAb1L,EAAiCsL,GAAmBhL,GAAW,GAAGsK,OAAO5K,GAC/FuL,EAAkB,IAAIG,EAAqBzL,GAC3C0L,EAAsBJ,EAAgB,GACtCK,EAAeL,EAAgBlH,OAAO,CAACwH,EAASR,KACpD,MAAMzL,EAAOwL,GAAgC9K,EAAS+K,GAKtD,OAJAQ,EAAQvM,IAAM,EAAIM,EAAKN,IAAKuM,EAAQvM,KACpCuM,EAAQtM,MAAQ,EAAIK,EAAKL,MAAOsM,EAAQtM,OACxCsM,EAAQrM,OAAS,EAAII,EAAKJ,OAAQqM,EAAQrM,QAC1CqM,EAAQpM,KAAO,EAAIG,EAAKH,KAAMoM,EAAQpM,MAC/BoM,GACNT,GAAgC9K,EAASqL,IAK5C,OAJAC,EAAa/N,MAAQ+N,EAAarM,MAAQqM,EAAanM,KACvDmM,EAAa5N,OAAS4N,EAAapM,OAASoM,EAAatM,IACzDsM,EAAahO,EAAIgO,EAAanM,KAC9BmM,EAAa7N,EAAI6N,EAAatM,IACvBsM,EAGT,MAAMnN,GAAW,CACfE,gBAAiBnB,IACf,IAAI,UACFC,EAAS,SACTC,EAAQ,SACRa,GACEf,EACJ,MAAO,CACLC,UAAW6K,EAA8B7K,EAAWsD,GAAgBrD,GAAWa,GAC/Eb,SAAU,IAAK2L,GAAc3L,GAC3BE,EAAG,EACHG,EAAG,KAIT8C,sDAAuDiL,GAAQjL,GAAsDiL,GACrH/K,gBAAiBgL,IACf,IAAI,QACFzL,GACEyL,EACJ,OAAOhL,GAAgBT,IAEzBG,UAAW5E,GAAS4E,EAAU5E,GAC9B8E,mBAAoBqL,IAClB,IAAI,QACF1L,GACE0L,EACJ,OAAOrL,EAAmBL,IAE5BE,sBAAuBsL,GAAQtL,GAAsBsL,GACrDzC,cAAe4C,IACb,IAAI,QACF3L,GACE2L,EACJ,OAAO5C,GAAc/I,IAEvB4L,eAAgBC,IACd,IAAI,QACF7L,GACE6L,EACJ,OAAO7L,EAAQ4L,mBAIb,GAAkB,CAACzO,EAAWC,EAAUqC,IAAY3B,EAAkBX,EAAWC,EAAU,CAC/Fe,eACGsB,IC/cL,QACApE,KAAA,gBACAD,WAAA,iBACA0Q,SAAA,GAEApN,KAAA,WACA,OACA,aACA,eAGAqN,QAAA,aAIAC,QAAA,WACA,gBACA,oBAEAC,QACA,CACA,gBADA,WAGA,+BACA,kBAKA,KATA,WAUA,mBAEA,cAZA,WAaA,gBAEA,mBAEA,kBAEA,YAnBA,WAoBA,wBACA,kBACA,QACA,yBACA,uCACA,kCACA,uBACA,uBACA,8BCrEuV,M,yBCQnVC,GAAY,gBACd,GACA,EACA,GACA,EACA,KACA,WACA,MAIa,GAAAA,G,qBCsGf,IACE7Q,KAAM,OACN8Q,WAAY,CACVC,cAAJ,GACIC,eAAJ,UC7H2V,MCOvV,GAAY,gBACd,GACAxS,EACAiB,GACA,EACA,KACA,KACA,MAIa,gB,8BCff,IAAIwR,EAAU,EAAQ,QACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAAC3S,EAAOC,EAAI0S,EAAS,MAC7DA,EAAQG,SAAQ9S,EAAOF,QAAU6S,EAAQG,QAE5C,IAAIC,EAAM,EAAQ,QAA+DF,QACpEE,EAAI,WAAYJ,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa","file":"js/brave_drop_menu-legacy.f47ba51c.js","sourcesContent":["// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".drop-button[data-v-dd61e21e]{position:relative;display:inline-block}.back-drop[data-v-dd61e21e]{position:fixed;display:flex;justify-content:center;align-items:flex-start;top:0;bottom:0;left:0;right:0;overflow:auto;z-index:10000;background-color:rgba(0,0,0,.6431372549019608)}.dropdown-items[data-v-dd61e21e]{position:absolute;z-index:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:opacity .7s ease 0s,color .7s ease 0s,transform .2s ease 0s;transform:translateX(0) translateZ(0)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","export * from \"-!../../node_modules/vue-style-loader/index.js??ref--7-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BraveDropMenu.vue?vue&type=style&index=0&id=dd61e21e&scoped=true&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"p-3 m-3 p-md-5 m-md-5\"},[_c('h1',{staticClass:\"mt-4\"},[_vm._v(\"Brave Drop Menu\")]),_c('p',[_vm._v(\"Toggleable, contextual overlays for displaying lists of links and more. \")]),_c('h2',{staticClass:\"my-4\"},[_vm._v(\"Example\")]),_c('p',[_vm._v(\"The following is an Example, Try clicking the button. \")]),_c('BraveDropMenu',{staticClass:\"me-3\",scopedSlots:_vm._u([{key:\"button\",fn:function(){return [_c('div',{staticClass:\"btn btn-primary text-white px-3 \",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi bi-plus-lg\"}),_vm._v(\" Button \"),_c('i',{staticClass:\"bi bi-chevron-down\"})])]},proxy:true},{key:\"menu\",fn:function(){return [_c('div',{staticClass:\"list-group bg-white shadow\",staticStyle:{\"min-width\":\"200px\"}},[_c('div',{staticClass:\"list-group-item list-group-item-action\",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi me-1 bi-person-plus\"}),_vm._v(\" A second link item\")]),_c('div',{staticClass:\"list-group-item list-group-item-action\",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi me-1 bi-envelope-plus\"}),_vm._v(\" A second link item\")])])]},proxy:true}])}),_c('BraveDropMenu',{scopedSlots:_vm._u([{key:\"button\",fn:function(){return [_c('div',{staticClass:\"btn btn-light  px-3 \",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi bi-plus-lg\"}),_vm._v(\" Button \"),_c('i',{staticClass:\"bi bi-chevron-down\"})])]},proxy:true},{key:\"menu\",fn:function(){return [_c('div',{staticClass:\"list-group bg-white shadow\",staticStyle:{\"min-width\":\"200px\"}},[_c('div',{staticClass:\"list-group-item list-group-item-action\",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi me-1 bi-person-plus\"}),_vm._v(\" A second link item\")]),_c('div',{staticClass:\"list-group-item list-group-item-action\",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi me-1 bi-envelope-plus\"}),_vm._v(\" A second link item\")])])]},proxy:true}])}),_c('p',{staticClass:\"mt-3\"},[_vm._v(\"This is a demo with inline text, \"),_c('BraveDropMenu',{scopedSlots:_vm._u([{key:\"button\",fn:function(){return [_c('span',{staticClass:\"link-primary\",attrs:{\"role\":\"button\"}},[_vm._v(\"click here to view\")])]},proxy:true},{key:\"menu\",fn:function(){return [_c('div',{staticClass:\"list-group bg-white shadow\",staticStyle:{\"min-width\":\"200px\"}},[_c('div',{staticClass:\"list-group-item list-group-item-action\",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi me-1 bi-person-plus\"}),_vm._v(\" A second link item\")]),_c('div',{staticClass:\"list-group-item list-group-item-action\",attrs:{\"role\":\"button\"}},[_c('i',{staticClass:\"bi me-1 bi-envelope-plus\"}),_vm._v(\" A second link item\")])])]},proxy:true}])})],1),_c('hr'),_c('h2',[_vm._v(\"Complete Example Code\")]),_c('BraveGistEmbed',{attrs:{\"url\":\"https://gist.github.com/shishirraven/d1a8bc204c7df9516d0138bb6258f5a4\"}}),_c('hr',{staticClass:\"my-5\"}),_c('h2',[_vm._v(\"How to use\")]),_c('h3',{staticClass:\"py-3\"},[_vm._v(\"1. Import the the component inside script tag. \")]),_vm._m(0),_c('h3',{staticClass:\"py-3\"},[_vm._v(\"2. Add to your components\")]),_vm._m(1),_c('h3',{staticClass:\"py-3\"},[_vm._v(\"3. Use in your template\")]),_vm._m(2),_vm._m(3),_c('ol',[_c('li',[_vm._v(\" Add the BraveDropMenuTag \"),_c('BraveGistEmbed',{attrs:{\"url\":\"https://gist.github.com/shishirraven/ec4e5ccddd4a87377ad19c89a4d5475d\"}})],1),_c('li',[_vm._v(\" Add the Button Template. \"),_c('BraveGistEmbed',{attrs:{\"url\":\"https://gist.github.com/shishirraven/1840e05254bffb6e88ad191308239821\"}})],1),_c('li',[_vm._v(\" Add the Menu. \"),_c('BraveGistEmbed',{attrs:{\"url\":\"https://gist.github.com/shishirraven/2a158f176e346dc74e6f515c411a98c8\"}})],1)]),_c('hr'),_c('h2',[_vm._v(\"Styling\")]),_c('p',[_vm._v(\"In the example I have used Bootstrap 5 to style the drop menu. But you can use any CSS Framework of your choice to style the menu.\")])],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"my-4\"},[_c('code',{staticClass:\"bg-light p-3 fs-5 \"},[_vm._v(\"import {BraveDropMenu} from \\\"bravevue\\\"\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"my-4\"},[_c('code',{staticClass:\"bg-light p-3 fs-5 \"},[_vm._v(\" components: { BraveDropMenu, ... }, \")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_vm._v(\" There are \"),_c('span',{staticClass:\"fw-bold\"},[_vm._v(\" 2 slots \")]),_vm._v(\" in the Component. \")])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_c('div',{staticClass:\"fw-bold\"},[_vm._v(\"Button\")]),_vm._v(\"- Here you add your button or whatever html you want to put on which the click should apply.\")]),_c('li',[_c('div',{staticClass:\"fw-bold\"},[_vm._v(\"Menu\")]),_vm._v(\"-here you keep your menu. \")])])}]\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"drop-button\"},[_c('div',{ref:\"button\",staticClass:\"drop-head\",on:{\"click\":function($event){return _vm.toggleVisiblity()}}},[_vm._t(\"button\",function(){return [_vm._v(\"Menu\")]})],2),(_vm.isVisible)?_c('div',{directives:[{name:\"clickoutside\",rawName:\"v-clickoutside\",value:(_vm.hideByOutside),expression:\"hideByOutside\"}],ref:\"menu\",staticClass:\"dropdown-items\"},[_vm._t(\"menu\")],2):_vm._e()])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default {\r\n  priority: 700,\r\n  bind: function (el, binding, vnode) {\r\n    el.clickOutsideEvent = function (event) {\r\n      // here I check that click was outside the el and his children\r\n      if (!(el == event.target || el.contains(event.target))) {\r\n        // and if it did, call method provided in attribute value\r\n        vnode.context[binding.expression](event);\r\n      }\r\n    };\r\n    document.body.addEventListener('click', el.clickOutsideEvent)\r\n  },\r\n  unbind: function (el) {\r\n    document.body.removeEventListener('click', el.clickOutsideEvent)\r\n  },\r\n}\r\n\r\n\r\n\r\n// Vue.directive('click-outside', {\r\n//   priority: 700,\r\n//   bind () {\r\n   \r\n//     let self  = this\r\n//     this.event = function (event) { \r\n//     \tconsole.log('emitting event')\r\n//     \tself.vm.$emit(self.expression,event) \r\n//  \t  }\r\n//     this.el.addEventListener('click', this.stopProp)\r\n//     document.body.addEventListener('click',this.event)\r\n//   },\r\n  \r\n//   unbind() {\r\n//   \tconsole.log('unbind')\r\n//     this.el.removeEventListener('click', this.stopProp)\r\n//     document.body.removeEventListener('click',this.event)\r\n//   },\r\n//   stopProp(event) {event.stopPropagation() }\r\n// })","function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getBasePlacement(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref) {\n  let {\n    reference,\n    floating,\n    placement\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  let coords;\n\n  switch (getBasePlacement(placement)) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] = coords[mainAxis] - (reference[length] / 2 - floating[length] / 2);\n      break;\n\n    case 'end':\n      coords[mainAxis] = coords[mainAxis] + (reference[length] / 2 - floating[length] / 2);\n      break;\n  }\n\n  return coords;\n}\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement({ ...rects,\n    placement\n  });\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let _debug_loop_count_ = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _debug_loop_count_++;\n\n      if (_debug_loop_count_ > 100) {\n        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));\n      }\n    }\n\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: data != null ? data : {}\n    };\n\n    if (reset) {\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement({ ...rects,\n          placement: statefulPlacement\n        }));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nasync function detectOverflow(middlewareArguments, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingParents',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = await platform.getClippingClientRect({\n    element: (await platform.isElement(element)) ? element : element.contextElement || (await platform.getDocumentElement({\n      element: elements.floating\n    })),\n    boundary,\n    rootBoundary\n  });\n  const elementClientRect = rectToClientRect(await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await platform.getOffsetParent({\n      element: elements.floating\n    }),\n    strategy\n  })); // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const basePlacement = getBasePlacement(placement);\n    const axis = getMainAxisFromPlacement(basePlacement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions({\n      element\n    });\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await platform.getOffsetParent({\n      element\n    });\n    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside of the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    return {\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects) {\n  const isStart = getAlignment(placement) === 'start';\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? isStart ? 'right' : 'left' : isStart ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst basePlacements = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + \"-start\", basePlacement + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getBasePlacement(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n\n      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {\n        return {};\n      }\n\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;\n      const currentPlacement = placements[currentIndex];\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getBasePlacement(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      return {\n        data: {\n          skip: true\n        },\n        reset: {\n          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement\n        }\n      };\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip, _middlewareData$flip2;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement\n      } = middlewareArguments;\n\n      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {\n        return {};\n      }\n\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const basePlacement = getBasePlacement(placement);\n      const isBasePlacement = basePlacement === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[basePlacement]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip3;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$slice$;\n\n              const placement = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0) - b.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        return {\n          data: {\n            skip: true\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return basePlacements.some(side => overflow[side] >= 0);\n}\n\nconst hide = () => ({\n  name: 'hide',\n\n  async fn(modifierArguments) {\n    const referenceOverflow = await detectOverflow(modifierArguments, {\n      elementContext: 'reference'\n    });\n    const floatingAltOverflow = await detectOverflow(modifierArguments, {\n      altBoundary: true\n    });\n    const referenceHiddenOffsets = getSideOffsets(referenceOverflow, modifierArguments.rects.reference);\n    const escapedOffsets = getSideOffsets(floatingAltOverflow, modifierArguments.rects.floating);\n    const referenceHidden = isAnySideFullyClipped(referenceHiddenOffsets);\n    const escaped = isAnySideFullyClipped(escapedOffsets);\n    return {\n      data: {\n        referenceHidden,\n        referenceHiddenOffsets,\n        escaped,\n        escapedOffsets\n      }\n    };\n  }\n\n});\n\nfunction convertValueToCoords(_ref) {\n  let {\n    placement,\n    rects,\n    value\n  } = _ref;\n  const basePlacement = getBasePlacement(placement);\n  const multiplier = ['left', 'top'].includes(basePlacement) ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value({ ...rects,\n    placement\n  }) : value;\n  const {\n    mainAxis,\n    crossAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    ...rawValue\n  };\n  return getMainAxisFromPlacement(basePlacement) === 'x' ? {\n    x: crossAxis,\n    y: mainAxis * multiplier\n  } : {\n    x: mainAxis * multiplier,\n    y: crossAxis\n  };\n}\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects\n      } = middlewareArguments;\n      const diffCoords = convertValueToCoords({\n        placement,\n        rects,\n        value\n      });\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getBasePlacement(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$size;\n\n      const {\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n\n      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {\n        return {};\n      }\n\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const basePlacement = getBasePlacement(placement);\n      const isEnd = getAlignment(placement) === 'end';\n      let heightSide;\n      let widthSide;\n\n      if (basePlacement === 'top' || basePlacement === 'bottom') {\n        heightSide = basePlacement;\n        widthSide = isEnd ? 'left' : 'right';\n      } else {\n        widthSide = basePlacement;\n        heightSide = isEnd ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        height: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        width: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      apply == null ? void 0 : apply({ ...dimensions,\n        ...rects\n      });\n      return {\n        data: {\n          skip: true\n        },\n        reset: {\n          rects: true\n        }\n      };\n    }\n\n  };\n};\n\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$inlin, _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy,\n        middlewareData\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n\n      if ((_middlewareData$inlin = middlewareData.inline) != null && _middlewareData$inlin.skip) {\n        return {};\n      }\n\n      const fallback = rectToClientRect(await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await platform.getOffsetParent({\n          element: elements.floating\n        }),\n        strategy\n      }));\n      const clientRects = Array.from((_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects({\n        element: elements.reference\n      }))) != null ? _await$platform$getCl : []);\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getBasePlacement(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftPlacement = getBasePlacement(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftPlacement ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      return {\n        data: {\n          skip: true\n        },\n        reset: {\n          rects: await platform.getElementRects({\n            reference: {\n              getBoundingClientRect\n            },\n            floating: elements.floating,\n            strategy\n          })\n        }\n      };\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return (value == null ? void 0 : value.toString()) === '[object Window]';\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  return {\n    width: clientRect.width / scaleX,\n    height: clientRect.height / scaleY,\n    top: clientRect.top / scaleY,\n    right: clientRect.right / scaleX,\n    bottom: clientRect.bottom / scaleY,\n    left: clientRect.left / scaleX,\n    x: clientRect.left / scaleX,\n    y: clientRect.top / scaleY\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isWindow(element)) {\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n\n    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\nfunction getScrollParents(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollParent = getScrollParent(node);\n  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollParent);\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getScrollParents(getParentNode(target)));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element) {\n  const clientRect = getBoundingClientRect(element);\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingParent(element, clippingParent) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  const clippingParents = getScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingClientRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary\n  } = _ref;\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromClippingParent(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingParent(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nconst platform = {\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: args => convertOffsetParentRelativeRectToViewportRelativeRect(args),\n  getOffsetParent: _ref2 => {\n    let {\n      element\n    } = _ref2;\n    return getOffsetParent(element);\n  },\n  isElement: value => isElement(value),\n  getDocumentElement: _ref3 => {\n    let {\n      element\n    } = _ref3;\n    return getDocumentElement(element);\n  },\n  getClippingClientRect: args => getClippingClientRect(args),\n  getDimensions: _ref4 => {\n    let {\n      element\n    } = _ref4;\n    return getDimensions(element);\n  },\n  getClientRects: _ref5 => {\n    let {\n      element\n    } = _ref5;\n    return element.getClientRects();\n  }\n};\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { computePosition, getScrollParents };\n","<template>\r\n\t<div class=\"drop-button\" >\r\n\t\t<div ref=\"button\" class=\"drop-head\" @click=\"toggleVisiblity()\">\r\n\t\t\t<slot name=\"button\" >Menu</slot>\r\n\t\t</div>\r\n\t\t<div ref=\"menu\"  class=\"dropdown-items\" v-clickoutside=\"hideByOutside\" v-if=\"isVisible\">\r\n\t\t\t<slot name=\"menu\"> </slot>\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\nimport clickoutside from \"@/directives/clickoutside.js\"\r\nimport {\r\n  computePosition,\r\n  flip,\r\n  shift,\r\n  offset,\r\n} from '@floating-ui/dom';\r\n\r\nexport default \r\n{\r\nname : 'BraveDropMenu',\r\ndirectives:{clickoutside},\r\ncomputed : {\r\n},\r\ndata : function(){\r\n\treturn {\r\n\t\tisVisible : false, \r\n\t\tskipToken : false,\r\n\t}\r\n}, // Data ends here\r\ncreated : function()\r\n{\r\n\t\r\n}, \r\nupdated:function(){\r\nif(this.isVisible)\r\n\t\t\t\tthis.setPosition()\t\r\n},\r\nmethods : \r\n{\r\n\t\ttoggleVisiblity()\r\n\t\t{\r\n\t\t\tthis.isVisible = !this.isVisible; \r\n\t\t\tthis.skipHide = true;\r\n\t\t\t\r\n\r\n\r\n\t\t}, \r\n\t\thide(){\r\n\t\t\tthis.isVisible=false;\r\n\t\t},\r\n\t\thideByOutside(){\r\n\t\t\tif(!this.skipHide)\r\n\t\t\t{\r\n\t\t\t\tthis.isVisible=false;\r\n\t\t\t}\r\n\t\t\tthis.skipHide =false;\r\n\t\t},\r\n\t\tsetPosition(){\r\n\t\t\tconst button = this.$refs.button;\r\n\t\t\tconst tooltip = this.$refs.menu;\r\n\t\t\tcomputePosition(button, tooltip, {\r\n\t\t\tplacement: 'bottom-start',\r\n\t\t\tmiddleware: [offset(6), flip(), shift({padding: 5})],\r\n\t\t\t}).then(({x, y}) => {\r\n\t\t\tObject.assign(tooltip.style, {\r\n\t\t\t\tleft: `${x}px`,\r\n\t\t\t\ttop: `${y}px`,\r\n\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n} // Method ends here\r\n}\r\n</script>\r\n<style scoped>\r\n.drop-button{\r\n\tposition: relative;\r\n\tdisplay: inline-block;\r\n}\r\n.back-drop{\r\n\tposition: fixed; \r\n\tdisplay: flex; \r\n\tjustify-content: center; \r\n\talign-items: flex-start;\r\n\ttop:0px;\r\n\tbottom:0px;\r\n\tleft:0px;\r\n\tright:0px;\r\n\toverflow: auto; \r\n\tz-index:10000;\r\n\tbackground-color: #000000a4;\r\n}\r\n.drop-item-container{\r\n\t/* position: relative; */\r\n}\r\n.dropdown-items{\r\n\tposition: absolute;\r\n\tz-index: 1;\r\n\r\n    user-select: none;\r\n    transition: opacity 700ms ease 0s, color 700ms ease 0s, transform 200ms ease 0s;\r\n    /* cursor: pointer;\r\n    opacity: 1;\r\n    position: absolute;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background: white;\r\n    bottom: 26px;\r\n    right: 26px;\r\n    width: 36px;\r\n    height: 36px;\r\n    border-radius: 100%;\r\n    font-size: 20px;\r\n    box-shadow: rgba(15, 15, 15, 0.1) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 2px 4px;\r\n    z-index: 101; */\r\n    transform: translateX(0px) translateZ(0px);\r\n\r\n}\r\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BraveDropMenu.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BraveDropMenu.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./BraveDropMenu.vue?vue&type=template&id=dd61e21e&scoped=true&\"\nimport script from \"./BraveDropMenu.vue?vue&type=script&lang=js&\"\nexport * from \"./BraveDropMenu.vue?vue&type=script&lang=js&\"\nimport style0 from \"./BraveDropMenu.vue?vue&type=style&index=0&id=dd61e21e&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"dd61e21e\",\n  null\n  \n)\n\nexport default component.exports","<template>\n  <div class=\"p-3 m-3 p-md-5 m-md-5\">\n\n    <h1 class=\"mt-4\">Brave Drop Menu</h1>\n    <p>Toggleable, contextual overlays for displaying lists of links and more.\n    </p>\n\n    <h2 class=\"my-4\">Example</h2> \n    <p>The following is an Example, Try clicking the button.  </p>\n\n    <BraveDropMenu class=\"me-3\">\n      <template #button>\n        <div role=\"button\" class=\"btn btn-primary text-white px-3 \"> <i class=\"bi bi-plus-lg\"></i> Button <i class=\"bi bi-chevron-down\"></i></div>\n      </template>\n      <template #menu>\n        <div class=\"list-group bg-white shadow\" style=\"min-width:200px;\" >\n          <div role=\"button\" class=\"list-group-item list-group-item-action\"><i class=\"bi me-1 bi-person-plus\"></i> A second link item</div>\n          <div role=\"button\" class=\"list-group-item list-group-item-action\"><i class=\"bi me-1 bi-envelope-plus\"></i> A second link item</div>\n        </div>\n      </template> \n    </BraveDropMenu>\n\n    <BraveDropMenu>\n      <template #button>\n        <div role=\"button\" class=\"btn btn-light  px-3 \"> <i class=\"bi bi-plus-lg\"></i> Button <i class=\"bi bi-chevron-down\"></i></div>\n      </template>\n      <template #menu>\n        <div class=\"list-group bg-white shadow\" style=\"min-width:200px;\" >\n          <div role=\"button\" class=\"list-group-item list-group-item-action\"><i class=\"bi me-1 bi-person-plus\"></i> A second link item</div>\n          <div role=\"button\" class=\"list-group-item list-group-item-action\"><i class=\"bi me-1 bi-envelope-plus\"></i> A second link item</div>\n        </div>\n      </template> \n    </BraveDropMenu>\n\n    \n   \n    <p class=\"mt-3\">This is a demo with inline text, <BraveDropMenu >\n      <template #button>\n        <span class=\"link-primary\" role=\"button\">click here to view</span> \n        </template>\n      <template #menu>\n        <div class=\"list-group bg-white shadow\" style=\"min-width:200px;\" >\n          <div role=\"button\" class=\"list-group-item list-group-item-action\"><i class=\"bi me-1 bi-person-plus\"></i> A second link item</div>\n          <div role=\"button\" class=\"list-group-item list-group-item-action\"><i class=\"bi me-1 bi-envelope-plus\"></i> A second link item</div>\n        </div>\n      </template> \n    </BraveDropMenu></p>\n\n    <hr>\n    <h2>Complete Example Code</h2>\n    \n    <BraveGistEmbed url=\"https://gist.github.com/shishirraven/d1a8bc204c7df9516d0138bb6258f5a4\"></BraveGistEmbed>\n\n\n\n    <hr class=\"my-5\">\n    <h2>How to use</h2>\n\n    <h3 class=\"py-3\">1. Import the the component inside script tag. </h3>\n\n    <div class=\"my-4\"><code class=\"bg-light p-3 fs-5 \">import {BraveDropMenu} from \"bravevue\"</code></div>\n\n    <h3 class=\"py-3\">2. Add to your components</h3>\n    \n    <div class=\"my-4\"><code class=\"bg-light p-3 fs-5 \">\n  components: {\n    BraveDropMenu, \n    ...\n  },  \n  </code>\n    </div>\n    <h3 class=\"py-3\">3. Use in your template</h3>\n    <p>\n      There are <span class=\"fw-bold\"> 2 slots </span> in the Component. \n    </p>\n    <ul>\n      <li><div class=\"fw-bold\">Button</div>- Here you add your button or whatever html you want to put on which the click should apply.</li>\n      <li><div class=\"fw-bold\">Menu</div>-here you keep your menu. </li>\n    </ul>\n\n\n    <ol>\n      <li>\n          Add the BraveDropMenuTag\n            <BraveGistEmbed url=\"https://gist.github.com/shishirraven/ec4e5ccddd4a87377ad19c89a4d5475d\"></BraveGistEmbed>\n            \n      </li>\n      <li>\n        Add the Button Template. \n        <BraveGistEmbed url=\"https://gist.github.com/shishirraven/1840e05254bffb6e88ad191308239821\"></BraveGistEmbed>\n       \n      </li>\n      <li>\n        Add the Menu. \n         <BraveGistEmbed url=\"https://gist.github.com/shishirraven/2a158f176e346dc74e6f515c411a98c8\"></BraveGistEmbed>\n\n      </li>\n    </ol>\n\n<hr>\n<h2>Styling</h2>\n<p>In the example I have used Bootstrap 5 to style the drop menu. But you can use any CSS Framework of your choice to style the menu.</p>\n<!-- \n    <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Brave Drop Menu\" src=\"https://codepen.io/shishirraven/embed/zYEeOVK?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/shishirraven/pen/zYEeOVK\">\n  Brave Drop Menu</a> by Shishir Raven (<a href=\"https://codepen.io/shishirraven\">@shishirraven</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe> -->\n\n\n\n\n\n  </div>\n</template>\n\n<script>\n// @ is an alias to /src\nimport BraveDropMenu from \"@/components/BraveDropMenu\"\n\nimport BraveGistEmbed from \"@/components/BraveGistEmbed\"\nexport default {\n  name: 'Home',\n  components: {\n    BraveDropMenu,\n    BraveGistEmbed\n  }\n}\n</script>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CompBraveDropMenu.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CompBraveDropMenu.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./CompBraveDropMenu.vue?vue&type=template&id=72cf947c&\"\nimport script from \"./CompBraveDropMenu.vue?vue&type=script&lang=js&\"\nexport * from \"./CompBraveDropMenu.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BraveDropMenu.vue?vue&type=style&index=0&id=dd61e21e&scoped=true&lang=css&\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"55e6f355\", content, true, {\"sourceMap\":false,\"shadowMode\":false});"],"sourceRoot":""}